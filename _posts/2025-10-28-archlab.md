---
layout: single
title: "新版Archlab踩坑记"  # 文章显示的标题（支持中文）
date: 2025-10-28 00:00:00  # 发布时间（与文件名日期一致）
categories: [习题]  # 文章分类（自己定，如“技术”“生活”）
tags: [ICS，ics,计算机系统导论]  # 标签（方便检索）
author_profile: true
---
>**⚠ 警告**
>
>**该博客仅供参考，请勿抄袭，后果自负**

***

因为PKU在2024年对archlab进行了重新构建，所以A大的博客有一些与目前版本不对应的地方，所以参考A大的博客进行了撰写

这是本人第一次写博客，若有不足之处，请谅解

致谢：
[Arthals的博客](https://arthals.ink/blog/arch-lab)
# Part A
本阶段任务并没有对旧版进行太大的更改，需要做的是在./archlab-project/misc
中修改三个.ys文件，并通过执行
```bash
./yas xxx.ys && ./yis xxx.yo
```
来运行这三个.ys文件，同时，你也可以用
```bash
export PATH=$PATH:/home/ubuntu/archlab-handout/archlab-project/target/debug
```
来暂时将grader的目录加入环境变量后运行
```bash
grader part-a
```
来为你的partA评分。
此外，推荐下载 VS Code Y86 语法扩展以获得高亮编码体验：
```text
https://marketplace.visualstudio.com/items?itemName=abhinavk99.y86-vscode
```

对于这部分的代码，更详细的思路分析可以去看A神的博客。
[Arthal的博客](https://arthals.ink/blog/arch-lab)
## sum.ys

  对sum.c进行逐步地分析后得到以下代码

```python
 	.pos 0 
	irmovq stack, %rsp  	# Set up stack pointer  
	call main		# Execute main program
	halt			# Terminate program 

# 示例链表（按8字节对齐）
.align 8
ele1:    # 第一个链表节点
.quad 0x00d  # 指向第二个节点（ele2）的指针（8字节）
.quad ele2 # 节点存储的值（8字节，十六进制）
ele2:    # 第二个链表节点
.quad 0x0e0 # 节点存储的值（8字节，十六进制）
.quad ele3  # 指向第三个节点（ele3）的指针（8字节）
ele3:    # 第三个链表节点
.quad 0xf00 # 节点存储的值（8字节，十六进制）
.quad 0     # 指向空地址（表示链表结尾）

main:
	irmovq ele1,%rdi	# 将参数移入对应寄存器
	call sum_list		
	ret 
sum_list:
    pushq %rbx  # 保存rbp
    xorq %rax,%rax  # rax置零
    jmp test    # 判断循环

loop:# 循环部分
    mrmovq (%rdi),%rsi  # Y86中不支持立即数加法，所以要把得到的数值先存入寄存器
    addq %rsi,%rax
    mrmovq 8(%rdi),%rdi #指针++

test:
    andq %rdi,%rdi  # 判断地址是否为0
    jne loop
    popq %rbx
    ret

# The stack starts here and grows to lower addresses
	.pos 0x200		
stack:	
```

这里比较坑的一点是，文件中并没有给出栈初始化和主函数代码，所以如果只实现了sum_list函数是无法运行的，栈初始化和主函数的代码可以参考./archlab-project/misc/y86-code中的.ys文件。
## rsum.ys
  
本题要求我们实现递归的累加函数，思路是将得到的数值加入栈中然后递归调用rsum_list,再将栈中数值弹出。
具体代码如下：
```python
 	.pos 0 
	irmovq stack, %rsp  	# Set up stack pointer  
	call main		# Execute main program
	halt			# Terminate program 

# 示例链表（按8字节对齐）
.align 8
ele1:    # 第一个链表节点
.quad 0x00d  # 指向第二个节点（ele2）的指针（8字节）
.quad ele2 # 节点存储的值（8字节，十六进制）
ele2:    # 第二个链表节点
.quad 0x0e0 # 节点存储的值（8字节，十六进制）
.quad ele3  # 指向第三个节点（ele3）的指针（8字节）
ele3:    # 第三个链表节点
.quad 0xf00 # 节点存储的值（8字节，十六进制）
.quad 0     # 指向空地址（表示链表结尾）

main:
	irmovq ele1,%rdi	
	call rsum_list		
	ret 
rsum_list:
    andq %rdi,%rdi  # 判断指针是否为空，若为空则return 0
    je base
    mrmovq  (%rdi),%rdx # 取值
    mrmovq 8(%rdi),%rdi # 指针++
    pushq %rdx  #将得到的数值压入栈中
    call rsum_list  #递归调用
    popq %rdx   # 将栈的值弹出
    addq %rdx,%rax
    ret
base:
    xorq %rax,%rax # rax置0，即return 0
    ret

# The stack starts here and grows to lower addresses
	.pos 0x200		
stack:	 
```
## bubble.ys
 具体代码如下
```python
	.pos 0
	irmovq	stack,%rsp
	call main
	halt

	.align 8
array:
	.quad 0xbca
	.quad 0xcba
	.quad 0xacb
	.quad 0xcab
	.quad 0xabc
	.quad 0xbac
# rdi *data rsi count
bubble_a:
	irmovq $8,%r8
	irmovq $1,%r9   #将需要的立即数先移入寄存器
	rrmovq %rdi,%rcx    # rcx=last
	rrmovq %rsi,%r10    # r10=i
	subq %r9,%r10
rcx_loop:   # 将last累加（count-1）次8，last=last = data + count - 1
	addq %r8,%rcx
	subq %r9,%r10
	jg rcx_loop
in_loop:				
	mrmovq (%rdx),%r11      # %r11 = 当前元素值（地址：%rdx）
	mrmovq 8(%rdx),%r12     # %r12 = 下一个元素值（地址：%rdx + 8）
	rrmovq %r11,%r13        # %r13 = 临时存储当前元素值（用于比较）
	subq %r12,%r13          # %r13 = 当前元素 - 下一个元素（判断大小）
	jle no_swap             # 若当前元素 <= 下一个元素，无需交换，跳至 
	# 交换逻辑：若当前元素 > 下一个元素，交换两者的值
	rrmovq %r12,%r13        # %r13 = 下一个元素值（临时存储，准备交换）
	rrmovq %r11,%r12        # %r12 = 当前元素值（完成值交换）
	rmmovq %r12,8(%rdx)     # 将交换后的"下一个元素值"存入地址 %rdx + 8
	rmmovq %r13,(%rdx)      # 将交换后的"当前元素值"存入地址 %rdx
no_swap:                   # 不交换时执行
	addq %r8,%rdx           # %rdx 加 8（移动到下一对相邻元素）
	rrmovq %rcx,%r10        # %r10 = 当前轮的 last 指针（边界）
	subq %rdx,%r10          # %r10 = last - 当前地址（判断是否到达本轮末尾）
	jg in_loop              # 若 %r10 > 0（未到末尾），继续内层循环

	# 内层循环结束后，更新外层循环的 last 指针（左移一个元素）
	subq %r8,%rcx           # last 指针减 8（下一轮的末尾边界左移）
	rrmovq %rcx,%r10        # %r10 = 更新后的 last 指针
	subq %rdi,%r10          # %r10 = last - 数组起始地址（判断是否还有未排序元素）
	jg out_loop             # 若 %r10 > 0（还有未排序元素），继续外层循环
	ret                     # 排序完成，返回调用者

main:
	irmovq array,%rdi
	irmovq $6,%rsi
	call bubble_a
	ret

	.pos 0x200
stack:
```
# Part B
本部分相对旧版来说，改动较大，也是本篇博客聚焦的主要部分，在Part B中你需要在./archlab-project/sim/src/architectures/extra内修改.rs文件。
在修改完后请使用
```bash
cargo build
```
来重新构建项目
同样的，你可以通过
```bash
grader part-b
```
获得你的评分
在做本节内容前，推荐安装 VS Code rust analyzer以获得高亮编码体验：
```md
https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer
```
需要注意的是，rust-analyzer必须要求工作区内有Cargo.toml文件，否则无法使用。
## IOPQ
本部分你将在seq_full.rs文件中添加IOPQ运算符，这部分的主要工作在Fetch，Decode与Execute部分，剩下部分则不太需要更改
### Fetch阶段
在这个阶段我们需要确保在取指时能正确读取IOPQ，包括认定IOPQ合法，需要读取寄存器，需要读取立即数,需要修改部分如下：
```rust
bool instr_valid = icode in // CMOVX is the same as RRMOVQ
    { NOP, HALT, CMOVX, IRMOVQ, RMMOVQ, MRMOVQ,
    OPQ, JX, CALL, RET, PUSHQ, POPQ, IOPQ };

// Does fetched instruction require a regid byte?
bool need_regids =
    icode in { CMOVX, OPQ, PUSHQ, POPQ, IRMOVQ, RMMOVQ, MRMOVQ, IOPQ };

// Does fetched instruction require a constant word?
bool need_valC = icode in { IRMOVQ, RMMOVQ, MRMOVQ, JX, CALL, IOPQ };
```
### Decode阶段
在decode阶段，由于IOPQ的srcA为F，即空寄存器，srcB为读取的寄存器rB，需要写入的寄存器（即dstE）为rB，dstM（需要写入的内存位置）为空，则我们需要修改以下部分：
```rust
u8 srcB = [
    icode in { OPQ, RMMOVQ, MRMOVQ, IOPQ } : ialign.rB;
    icode in { PUSHQ, POPQ, CALL, RET } : RSP;
    true : RNONE; // Don't need register
];
u8 dstE = [
    icode in { CMOVX } && cnd : ialign.rB;
    icode in { IRMOVQ, OPQ, IOPQ} : ialign.rB;
    icode in { PUSHQ, POPQ, CALL, RET } : RSP;
    true : RNONE; // Don't write any register
];
```
### Execute阶段
在execute阶段，我们需要读取两个运算的数以及运算符，并且不要忘记了IOPQ同样需要设置条件码
```rust
// Select input A to ALU
u64 aluA = [
    icode in { CMOVX, OPQ} : reg_read.valA;
    icode in { IRMOVQ, RMMOVQ, MRMOVQ, IOPQ } : ialign.valC;
    icode in { CALL, PUSHQ } : NEG_8;
    icode in { RET, POPQ } : 8;
    // Other instructions don't need ALU
];

// Select input B to ALU
u64 aluB = [
    icode in { RMMOVQ, MRMOVQ, OPQ, CALL,
              PUSHQ, RET, POPQ , IOPQ } : reg_read.valB;
    icode in { CMOVX, IRMOVQ } : 0;
    // Other instructions don't need ALU
];

// Set the ALU function
u8 alufun = [
    icode in { OPQ, IOPQ } : ifun;
    true : ADD;
];

bool set_cc = icode in { OPQ, IOPQ };
```
## Pipeline
本部分你将参考pipe_s2.rs文件填写一系列的pipeline文件
推荐在填写时使用vscode的文件比对功能。
### pipe_s3a
在 pipe_s3a中，我们