---
layout: single
title: "新版Archlab踩坑记"  # 文章显示的标题（支持中文）
date: 2025-10-28 00:00:00  # 发布时间（与文件名日期一致）
categories: [习题]  # 文章分类（自己定，如“技术”“生活”）
tags: [ICS,ics,计算机系统导论]  # 标签（方便检索）
author_profile: true
---
>**⚠ 警告**
>
>**该博客仅供参考，请勿抄袭，后果自负**

***

因为PKU在2024年对archlab进行了重新构建，所以A大的博客有一些与目前版本不对应的地方，所以参考A大的博客进行了撰写

这是本人第一次写博客，若有不足之处，请谅解

致谢：
[Arthals的博客](https://arthals.ink/blog/arch-lab)
# Part A
本阶段任务并没有对旧版进行太大的更改，需要做的是在./archlab-project/misc
中修改三个.ys文件，并通过执行
```bash
./yas xxx.ys && ./yis xxx.yo
```
来运行这三个.ys文件，同时，你也可以用
```bash
export PATH=$PATH:/home/ubuntu/archlab-handout/archlab-project/target/debug
```
来暂时将grader的目录加入环境变量后运行
```bash
grader part-a
```
来为你的partA评分。
此外，推荐下载 VS Code Y86 语法扩展以获得高亮编码体验：
```text
https://marketplace.visualstudio.com/items?itemName=abhinavk99.y86-vscode
```

对于这部分的代码，更详细的思路分析可以去看A神的博客。
[Arthals的博客](https://arthals.ink/blog/arch-lab)
## sum.ys

  对sum.c进行逐步地分析后得到以下代码

```python
 	.pos 0 
	irmovq stack, %rsp  	# Set up stack pointer  
	call main		# Execute main program
	halt			# Terminate program 

# 示例链表（按8字节对齐）
.align 8
ele1:    # 第一个链表节点
.quad 0x00d  # 指向第二个节点（ele2）的指针（8字节）
.quad ele2 # 节点存储的值（8字节，十六进制）
ele2:    # 第二个链表节点
.quad 0x0e0 # 节点存储的值（8字节，十六进制）
.quad ele3  # 指向第三个节点（ele3）的指针（8字节）
ele3:    # 第三个链表节点
.quad 0xf00 # 节点存储的值（8字节，十六进制）
.quad 0     # 指向空地址（表示链表结尾）

main:
	irmovq ele1,%rdi	# 将参数移入对应寄存器
	call sum_list		
	ret 
sum_list:
    pushq %rbx  # 保存rbp
    xorq %rax,%rax  # rax置零
    jmp test    # 判断循环

loop:# 循环部分
    mrmovq (%rdi),%rsi  # Y86中不支持立即数加法，所以要把得到的数值先存入寄存器
    addq %rsi,%rax
    mrmovq 8(%rdi),%rdi #指针++

test:
    andq %rdi,%rdi  # 判断地址是否为0
    jne loop
    popq %rbx
    ret

# The stack starts here and grows to lower addresses
	.pos 0x200		
stack:	
```

这里比较坑的一点是，文件中并没有给出栈初始化和主函数代码，所以如果只实现了sum_list函数是无法运行的，栈初始化和主函数的代码可以参考./archlab-project/misc/y86-code中的.ys文件。
## rsum.ys
  
本题要求我们实现递归的累加函数，思路是将得到的数值加入栈中然后递归调用rsum_list,再将栈中数值弹出。
具体代码如下：
```python
 	.pos 0 
	irmovq stack, %rsp  	# Set up stack pointer  
	call main		# Execute main program
	halt			# Terminate program 

# 示例链表（按8字节对齐）
.align 8
ele1:    # 第一个链表节点
.quad 0x00d  # 指向第二个节点（ele2）的指针（8字节）
.quad ele2 # 节点存储的值（8字节，十六进制）
ele2:    # 第二个链表节点
.quad 0x0e0 # 节点存储的值（8字节，十六进制）
.quad ele3  # 指向第三个节点（ele3）的指针（8字节）
ele3:    # 第三个链表节点
.quad 0xf00 # 节点存储的值（8字节，十六进制）
.quad 0     # 指向空地址（表示链表结尾）

main:
	irmovq ele1,%rdi	
	call rsum_list		
	ret 
rsum_list:
    andq %rdi,%rdi  # 判断指针是否为空，若为空则return 0
    je base
    mrmovq  (%rdi),%rdx # 取值
    mrmovq 8(%rdi),%rdi # 指针++
    pushq %rdx  #将得到的数值压入栈中
    call rsum_list  #递归调用
    popq %rdx   # 将栈的值弹出
    addq %rdx,%rax
    ret
base:
    xorq %rax,%rax # rax置0，即return 0
    ret

# The stack starts here and grows to lower addresses
	.pos 0x200		
stack:	 
```
## bubble.ys
 具体代码如下
```python
	.pos 0
	irmovq	stack,%rsp
	call main
	halt

	.align 8
array:
	.quad 0xbca
	.quad 0xcba
	.quad 0xacb
	.quad 0xcab
	.quad 0xabc
	.quad 0xbac
# rdi *data rsi count
bubble_a:
	irmovq $8,%r8
	irmovq $1,%r9   #将需要的立即数先移入寄存器
	rrmovq %rdi,%rcx    # rcx=last
	rrmovq %rsi,%r10    # r10=i
	subq %r9,%r10
rcx_loop:   # 将last累加（count-1）次8，last=last = data + count - 1
	addq %r8,%rcx
	subq %r9,%r10
	jg rcx_loop
in_loop:				
	mrmovq (%rdx),%r11      # %r11 = 当前元素值（地址：%rdx）
	mrmovq 8(%rdx),%r12     # %r12 = 下一个元素值（地址：%rdx + 8）
	rrmovq %r11,%r13        # %r13 = 临时存储当前元素值（用于比较）
	subq %r12,%r13          # %r13 = 当前元素 - 下一个元素（判断大小）
	jle no_swap             # 若当前元素 <= 下一个元素，无需交换，跳至 
	# 交换逻辑：若当前元素 > 下一个元素，交换两者的值
	rrmovq %r12,%r13        # %r13 = 下一个元素值（临时存储，准备交换）
	rrmovq %r11,%r12        # %r12 = 当前元素值（完成值交换）
	rmmovq %r12,8(%rdx)     # 将交换后的"下一个元素值"存入地址 %rdx + 8
	rmmovq %r13,(%rdx)      # 将交换后的"当前元素值"存入地址 %rdx
no_swap:                   # 不交换时执行
	addq %r8,%rdx           # %rdx 加 8（移动到下一对相邻元素）
	rrmovq %rcx,%r10        # %r10 = 当前轮的 last 指针（边界）
	subq %rdx,%r10          # %r10 = last - 当前地址（判断是否到达本轮末尾）
	jg in_loop              # 若 %r10 > 0（未到末尾），继续内层循环

	# 内层循环结束后，更新外层循环的 last 指针（左移一个元素）
	subq %r8,%rcx           # last 指针减 8（下一轮的末尾边界左移）
	rrmovq %rcx,%r10        # %r10 = 更新后的 last 指针
	subq %rdi,%r10          # %r10 = last - 数组起始地址（判断是否还有未排序元素）
	jg out_loop             # 若 %r10 > 0（还有未排序元素），继续外层循环
	ret                     # 排序完成，返回调用者

main:
	irmovq array,%rdi
	irmovq $6,%rsi
	call bubble_a
	ret

	.pos 0x200
stack:
```
# Part B
本部分相对旧版来说，改动较大，也是本篇博客聚焦的主要部分，在Part B中你需要在./archlab-project/sim/src/architectures/extra内修改.rs文件。
在修改完后请使用
```bash
cargo build
```
来重新构建项目
同样的，你可以通过
```bash
grader part-b
```
获得你的评分

在做本节内容前，推荐安装 VS Code rust analyzer以获得高亮编码体验：
```md
https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer
```
需要注意的是，rust-analyzer必须要求工作区内有Cargo.toml文件，否则无法使用。
## IOPQ
本部分你将在seq_full.rs文件中添加IOPQ运算符，这部分的主要工作在Fetch，Decode与Execute部分，剩下部分则不太需要更改
### Fetch阶段
在这个阶段我们需要确保在取指时能正确读取IOPQ，包括认定IOPQ合法，需要读取寄存器，需要读取立即数,需要修改部分如下：
```rust
bool instr_valid = icode in // CMOVX is the same as RRMOVQ
    { NOP, HALT, CMOVX, IRMOVQ, RMMOVQ, MRMOVQ,
    OPQ, JX, CALL, RET, PUSHQ, POPQ, IOPQ };

// Does fetched instruction require a regid byte?
bool need_regids =
    icode in { CMOVX, OPQ, PUSHQ, POPQ, IRMOVQ, RMMOVQ, MRMOVQ, IOPQ };

// Does fetched instruction require a constant word?
bool need_valC = icode in { IRMOVQ, RMMOVQ, MRMOVQ, JX, CALL, IOPQ };
```
### Decode阶段
在decode阶段，由于IOPQ的srcA为F，即空寄存器，srcB为读取的寄存器rB，需要写入的寄存器（即dstE）为rB，dstM（需要写入的内存位置）为空，则我们需要修改以下部分：
```rust
u8 srcB = [
    icode in { OPQ, RMMOVQ, MRMOVQ, IOPQ } : ialign.rB;
    icode in { PUSHQ, POPQ, CALL, RET } : RSP;
    true : RNONE; // Don't need register
];
u8 dstE = [
    icode in { CMOVX } && cnd : ialign.rB;
    icode in { IRMOVQ, OPQ, IOPQ} : ialign.rB;
    icode in { PUSHQ, POPQ, CALL, RET } : RSP;
    true : RNONE; // Don't write any register
];
```
### Execute阶段
在execute阶段，我们需要读取两个运算的数以及运算符，并且不要忘记了IOPQ同样需要设置条件码
```rust
// Select input A to ALU
u64 aluA = [
    icode in { CMOVX, OPQ} : reg_read.valA;
    icode in { IRMOVQ, RMMOVQ, MRMOVQ, IOPQ } : ialign.valC;
    icode in { CALL, PUSHQ } : NEG_8;
    icode in { RET, POPQ } : 8;
    // Other instructions don't need ALU
];

// Select input B to ALU
u64 aluB = [
    icode in { RMMOVQ, MRMOVQ, OPQ, CALL,
              PUSHQ, RET, POPQ , IOPQ } : reg_read.valB;
    icode in { CMOVX, IRMOVQ } : 0;
    // Other instructions don't need ALU
];

// Set the ALU function
u8 alufun = [
    icode in { OPQ, IOPQ } : ifun;
    true : ADD;
];

bool set_cc = icode in { OPQ, IOPQ };
```
## Pipeline
本部分你将参考pipe_s2.rs文件填写一系列的pipeline文件
推荐在填写时使用vscode的文件比对功能。
### pipe_s3a
在 pipe_s3a中，我们将把流水线分为三阶段，分别是Fetch阶段，Decode阶段以及Execute阶段（包含Execute之后的所有阶段）
在这个阶段，我们主要处理的是取指和data hazard两个问题。当然还包含其他的填空，但是在这里就不再赘述

在取指阶段，因为不同的阶段我们才能确定具体的取指数据,因此，我们需要读取D与E的icode以获得地址
```rust
u64 f_pc = [
    // Call.  Use instruction constant
    // If the previous instruction is CALL, the constant value should be the next PC
    // valC is from Fetch Stage, thus the last cycle
    D.icode == CALL : D.valC;
    // Taken branch.  Use instruction constant
    E.icode == JX && e_cnd : E.valC;
    // Completion of RET instruction.  Use value from stack
    // valM is from DEMW stage, thus the current cycle
    E.icode == RET : e_valM;//在E阶段e_valM得到的是栈中弹出的值
    // Default: Use incremented PC
    1 : F.valP;
];
```
值得注意的是，icode对应的阶段和读取的值对应的阶段应该是相同的。

关于data hazard，判定data hazard的方法其实就在于看D阶段读取的寄存器是否是E阶段所要改动的寄存器，即可写出
```rust
bool data_harzard = (d_srcA != RNONE && d_srcA in { e_dstE, e_dstM })
    || (d_srcB != RNONE && d_srcB in { e_dstE, e_dstM });
```
在遇到data hazard时，我们需要停滞一个阶段，即E阶段bubble，F,D阶段stall，可写出：
```rust
bool f_stall = D.icode in { JX, RET } || data_harzard;

@set_stage(f, {
    stall: f_stall,
});


bool d_stall = data_harzard;

bool d_bubble = D.icode in { JX,RET } && !d_stall;

@set_stage(d, {
    stall: d_stall,
    bubble: d_bubble,
});

// A data hazard has occurred, and the preceding stage is waiting. 
// This stage has nothing to do, so we insert a bubble.
bool e_bubble = data_harzard;
```
### pipe_s3b
在这个阶段，我们主要处理的是使用forward来解决data hazard
```rust
u64 d_valA = [
    d_srcA == e_dstE : e_valE;
    d_srcA == e_dstM : e_valM;
    1: reg_read.valA;
];
u64 d_valB = [
    d_srcB == e_dstE : e_valE;
    d_srcB == e_dstM : e_valM;
    1: reg_read.valB;
];
```
通过在Decode阶段更改读取的值，我们可以避免在data hazard出现的停顿
同样的，我们也不再需要d_stall了
### pipe_s3c
在这个阶段，我们要使用branch prediction来解决icode为JX时的停顿问题
为了做branch prediction，我们先预测出一个pc
```rust
u64 f_pred_pc = [
    // Always take the jump
    f_icode == JX : f_valC;
    // Default: Use incremented PC
    1: f_valP;
];
```
在取指令的时候我们就可以进行判断，当JX && !e_cnd时，我们就回去取valP
```rust
u64 f_pc = [
    // Call.  Use instruction constant
    // If the previous instruction is CALL, the constant value should be the next PC
    // valC is from Fetch Stage, thus the last cycle
    D.icode == CALL : D.valC;
    // Branch misprediction.  Use incremental PC
    E.icode == JX && !e_cnd : E.valP;
    // Completion of RET instruction.  Use value from stack
    // valM is from DEMW stage, thus the current cycle
    E.icode == RET : e_valM;
    // Default: Use predicted PC
    1 : F.pred_pc;
];
```
同时，branch prediction也会给我们带来副作用，当预测错误的时候，我们需要E阶段bubble，把错误的在D阶段的指令给排除。
当D阶段的icode是RET,E阶段是JX时，我们已经将D阶段指令排除了，所以不需要对RET进行额外的处理。
```rust
// If a branch misprediction is detected during the Execute stage, it means that
// the instruction currently in the Decode stage is invalid. Therefore, the next
// cycle’s Execute stage needs to insert a bubble.
bool branch_mispred = E.icode == JX && !e_cnd;

// If the current instruction in the Decode stage is a RET, then the instruction
// in the current Fetch stage is invalid. Therefore, the next cycle’s Fetch stage 
// needs to insert a bubble.
bool ret_harzard = D.icode == RET;

// If both a branch misprediction and a RET hazard occur at the same time, since 
// the jump instruction is executed before the RET, the RET should not have been 
// executed, so a stall is not needed.
bool f_stall = ret_harzard && !branch_mispred;

@set_stage(f, {
    stall: f_stall,
});


bool d_stall = false;

// If both a branch misprediction and a ret hazard occur at the same time,
// since the jump instruction is executed before the RET, the RET should not
// have been executed. Therefore, a bubble is not needed.
bool d_bubble = ret_harzard && !branch_mispred;

@set_stage(d, {
    stall: d_stall,
    bubble: d_bubble,
});

bool e_bubble = branch_mispred;
```
### pipe_s3d
本阶段只是将寄存器读写在硬件层面上写在了一起，流水线逻辑没有太大改变，所以不再赘述
### pipe_s4a
本阶段正式进入了四阶段流水线，分别是Fetch阶段，Decode阶段，Execute阶段以及Memory阶段（包括内存与寄存器的访问）
在这个阶段，会出现load use hazard，即D阶段读取的数据，是E阶段得到的数据所存放的地方，在出现这种情况的时候，我们需要对流水线进行特殊处理。
```rust
// If a branch misprediction is detected during the Execute stage, it means that
// the instruction currently in the Decode stage is invalid. Therefore, the next
// cycle’s Execute stage needs to insert a bubble.
bool branch_mispred = E.icode == JX && !e_cnd;

// If a RET instruction is detected in either the Decode or Execute stage, then
// the instruction in the current Fetch stage is invalid. Therefore, a bubble
// needs to be inserted in the Fetch stage for the next cycle.
//
// In fact, when E.icode == RET, the instruction in the current Decode stage is 
// also invalid, but because the D.icode in the previous cycle was RET, at this
// point D.icode == NOP, so there's no need to add a condition for e_bubble.
bool ret_harzard = RET in { D.icode, E.icode };

// This instruction needs to read from a register whose data was loaded from
// memory by the previous instruction, but the previous instruction is still in
// the Execute stage, causing a data hazard.
bool load_use_harzard = E.icode in { MRMOVQ, POPQ } && E.dstM in { d_srcA, d_srcB };
// an equivalent expression:
// bool load_use_harzard = E.dstM != RNONE && E.dstM in { d_srcA, d_srcB };

// If both a branch misprediction and a RET hazard occur at the same time, 
// since the jump instruction is executed before the RET, the RET should not be 
// executed, so no stall is required.
bool f_stall = ret_harzard && !branch_mispred || load_use_harzard;

@set_stage(f, {
    stall: f_stall,
});


bool d_stall = load_use_harzard;

// If both a branch misprediction and a RET hazard occur at the same time,
// since the jump instruction is executed before the RET, the RET should not
// have been executed, so a bubble is not needed.
// 
// Actually, ret_harzard and d_stall cannot be true at the same time.
bool d_bubble = ret_harzard && !branch_mispred && !d_stall;

@set_stage(d, {
    stall: d_stall,
    bubble: d_bubble,
});

bool e_bubble = branch_mispred || load_use_harzard ;

@set_stage(e, {
    bubble: e_bubble,
});
```
在出现 load use hazard的时候，我们使流水线停滞，在E阶段进行bubble，同时注意到，因为E阶段和M阶段分开了，RET指令的数值要在M阶段才能得到，所以 RET hazard需要处理RET分别在D，E阶段的情况。
### pipe_s4b pipe_s4c
这两个阶段只是改变了一些变量，对流水线本身的逻辑改变不大，故不再赘述
# Part C
你需要更改./archlab-project/sim/src/architectures/extra/ncopy.rs与./archlab-project/misc/ncopy.ys
在这个阶段，因为我的实现也不足够好，所以我只是大概讲述我自己的思路，我自己的思路在很大程度上参考了A大的博客，同时如果希望得到更详细，或者结果更优的思路，请阅读A大的博客：
[Arthals的博客](https://arthals.ink/blog/arch-lab)
请记得更新流水线结构时运行
```bash
cargo build
```
## 循环展开
循环展开其实并不难理解，实际上他就是把代码从：
```c
for(int i=0;i<n;i++){
	sum+=i;
}
```
变成了：
```c
for(int i=0;i<n;i+=8){
	sum+=i;
	sum+=i+1;
	sum+=i+2;
	sum+=i+3;
	sum+=i+4;
	sum+=i+5;
	sum+=i+6;
	sum+=i+7;
}
```
通过减少跳转，降低了流水线停滞成本
这是我的代码实现参考：
```python
loop_unroll:
    mrmovq (%rdi),%r8
    mrmovq 8(%rdi),%r9
    mrmovq 16(%rdi),%r10
    mrmovq 24(%rdi),%r11
    mrmovq 32(%rdi),%r12
    mrmovq 40(%rdi),%r13
    mrmovq 48(%rdi),%r14
    mrmovq 56(%rdi),%rcx
   # process r8
    andq %r8,%r8
    rmmovq %r8,(%rsi)
    jle LU1
    iaddq $1,%rax
LU1:
    andq %r9,%r9
    rmmovq %r9,8(%rsi)
    jle LU2
    iaddq $1,%rax
LU2:
    andq %r10,%r10
    rmmovq %r10,16(%rsi)
    jle LU3
    iaddq $1,%rax
LU3:
    andq %r11,%r11
    rmmovq %r11,24(%rsi)
    jle LU4
    iaddq $1,%rax
LU4:
    andq %r12,%r12
    rmmovq %r12,32(%rsi)
    jle LU5
    iaddq $1,%rax
LU5:
    andq %r13,%r13
    rmmovq %r13,40(%rsi)
    jle LU6
    iaddq $1,%rax
LU6:
    andq %r14,%r14
    rmmovq %r14,48(%rsi)
    jle LU7
    iaddq $1,%rax
LU7:
    andq %rcx,%rcx
    rmmovq %rcx,56(%rsi)
    jle LU8
    iaddq $1,%rax
LU8:
    iaddq $64,%rdi
    iaddq $64,%rsi
    iaddq $-8,%rdx
    andq %rdx,%rdx
    jge loop_unroll
```
## 戳气泡
众所周知，在OPQ和JX连续调用的时候，会造成数据冒险，所以我们在之中插入一些指令就可以避免流水线停止
```python
 	andq %r8,%r8
    rmmovq %r8,48(%rsi)
    mrmovq 40(%rdi),%r8
    jle bi_r6
```
## 使用IOPQ与余数的二叉树搜索
具体思路不再赘述，可参考A大的博客
## 最终结果
使用了pipe_full.rs的架构与上述优化思路，最终cpe: 8.068417510897504, arch cost: 4, score: 55.7001,因为本人的ICS是自选PF，所以暂时也满足了。
