---
layout: single
title: "新版Archlab踩坑记"  # 文章显示的标题（支持中文）
date: 2025-10-28 00:00:00  # 发布时间（与文件名日期一致）
categories: [习题]  # 文章分类（自己定，如“技术”“生活”）
tags: [ICS,ics,计算机系统导论]  # 标签（方便检索）
author_profile: true
---
>**⚠ 警告**
>
>**该博客仅供参考，请勿抄袭，后果自负**

***

因为PKU在2024年对archlab进行了重新构建，所以A大的博客有一些与目前版本不对应的地方，所以参考A大的博客进行了撰写

这是本人第一次写博客，若有不足之处，请谅解

致谢：
[Arthals的博客](https://arthals.ink/blog/arch-lab)
# Part A
本阶段任务并没有对旧版进行太大的更改，需要做的是在./archlab-project/misc
中修改三个.ys文件，并通过执行
```bash
./yas xxx.ys && ./yis xxx.yo
```
来运行这三个.ys文件，同时，你也可以用
```bash
export PATH=$PATH:/home/ubuntu/archlab-handout/archlab-project/target/debug
```
来暂时将grader的目录加入环境变量后运行
```bash
grader part-a
```
来为你的partA评分。
此外，推荐下载 VS Code Y86 语法扩展以获得高亮编码体验：
```text
https://marketplace.visualstudio.com/items?itemName=abhinavk99.y86-vscode
```

对于这部分的代码，更详细的思路分析可以去看A神的博客。
[Arthal的博客](https://arthals.ink/blog/arch-lab)
## sum.ys

  对sum.c进行逐步地分析后得到以下代码

```python
 	.pos 0 
	irmovq stack, %rsp  	# Set up stack pointer  
	call main		# Execute main program
	halt			# Terminate program 

# 示例链表（按8字节对齐）
.align 8
ele1:    # 第一个链表节点
.quad 0x00d  # 指向第二个节点（ele2）的指针（8字节）
.quad ele2 # 节点存储的值（8字节，十六进制）
ele2:    # 第二个链表节点
.quad 0x0e0 # 节点存储的值（8字节，十六进制）
.quad ele3  # 指向第三个节点（ele3）的指针（8字节）
ele3:    # 第三个链表节点
.quad 0xf00 # 节点存储的值（8字节，十六进制）
.quad 0     # 指向空地址（表示链表结尾）

main:
	irmovq ele1,%rdi	# 将参数移入对应寄存器
	call sum_list		
	ret 
sum_list:
    pushq %rbx  # 保存rbp
    xorq %rax,%rax  # rax置零
    jmp test    # 判断循环

loop:# 循环部分
    mrmovq (%rdi),%rsi  # Y86中不支持立即数加法，所以要把得到的数值先存入寄存器
    addq %rsi,%rax
    mrmovq 8(%rdi),%rdi #指针++

test:
    andq %rdi,%rdi  # 判断地址是否为0
    jne loop
    popq %rbx
    ret

# The stack starts here and grows to lower addresses
	.pos 0x200		
stack:	
```

这里比较坑的一点是，文件中并没有给出栈初始化和主函数代码，所以如果只实现了sum_list函数是无法运行的，栈初始化和主函数的代码可以参考./archlab-project/misc/y86-code中的.ys文件。
## rsum.ys
  
本题要求我们实现递归的累加函数，思路是将得到的数值加入栈中然后递归调用rsum_list,再将栈中数值弹出。
具体代码如下：
```python
 	.pos 0 
	irmovq stack, %rsp  	# Set up stack pointer  
	call main		# Execute main program
	halt			# Terminate program 

# 示例链表（按8字节对齐）
.align 8
ele1:    # 第一个链表节点
.quad 0x00d  # 指向第二个节点（ele2）的指针（8字节）
.quad ele2 # 节点存储的值（8字节，十六进制）
ele2:    # 第二个链表节点
.quad 0x0e0 # 节点存储的值（8字节，十六进制）
.quad ele3  # 指向第三个节点（ele3）的指针（8字节）
ele3:    # 第三个链表节点
.quad 0xf00 # 节点存储的值（8字节，十六进制）
.quad 0     # 指向空地址（表示链表结尾）

main:
	irmovq ele1,%rdi	
	call rsum_list		
	ret 
rsum_list:
    andq %rdi,%rdi  # 判断指针是否为空，若为空则return 0
    je base
    mrmovq  (%rdi),%rdx # 取值
    mrmovq 8(%rdi),%rdi # 指针++
    pushq %rdx  #将得到的数值压入栈中
    call rsum_list  #递归调用
    popq %rdx   # 将栈的值弹出
    addq %rdx,%rax
    ret
base:
    xorq %rax,%rax # rax置0，即return 0
    ret

# The stack starts here and grows to lower addresses
	.pos 0x200		
stack:	 
```
## bubble.ys
 具体代码如下
```python
	.pos 0
	irmovq	stack,%rsp
	call main
	halt

	.align 8
array:
	.quad 0xbca
	.quad 0xcba
	.quad 0xacb
	.quad 0xcab
	.quad 0xabc
	.quad 0xbac
# rdi *data rsi count
bubble_a:
	irmovq $8,%r8
	irmovq $1,%r9   #将需要的立即数先移入寄存器
	rrmovq %rdi,%rcx    # rcx=last
	rrmovq %rsi,%r10    # r10=i
	subq %r9,%r10
rcx_loop:   # 将last累加（count-1）次8，last=last = data + count - 1
	addq %r8,%rcx
	subq %r9,%r10
	jg rcx_loop
in_loop:				
	mrmovq (%rdx),%r11      # %r11 = 当前元素值（地址：%rdx）
	mrmovq 8(%rdx),%r12     # %r12 = 下一个元素值（地址：%rdx + 8）
	rrmovq %r11,%r13        # %r13 = 临时存储当前元素值（用于比较）
	subq %r12,%r13          # %r13 = 当前元素 - 下一个元素（判断大小）
	jle no_swap             # 若当前元素 <= 下一个元素，无需交换，跳至 
	# 交换逻辑：若当前元素 > 下一个元素，交换两者的值
	rrmovq %r12,%r13        # %r13 = 下一个元素值（临时存储，准备交换）
	rrmovq %r11,%r12        # %r12 = 当前元素值（完成值交换）
	rmmovq %r12,8(%rdx)     # 将交换后的"下一个元素值"存入地址 %rdx + 8
	rmmovq %r13,(%rdx)      # 将交换后的"当前元素值"存入地址 %rdx
no_swap:                   # 不交换时执行
	addq %r8,%rdx           # %rdx 加 8（移动到下一对相邻元素）
	rrmovq %rcx,%r10        # %r10 = 当前轮的 last 指针（边界）
	subq %rdx,%r10          # %r10 = last - 当前地址（判断是否到达本轮末尾）
	jg in_loop              # 若 %r10 > 0（未到末尾），继续内层循环

	# 内层循环结束后，更新外层循环的 last 指针（左移一个元素）
	subq %r8,%rcx           # last 指针减 8（下一轮的末尾边界左移）
	rrmovq %rcx,%r10        # %r10 = 更新后的 last 指针
	subq %rdi,%r10          # %r10 = last - 数组起始地址（判断是否还有未排序元素）
	jg out_loop             # 若 %r10 > 0（还有未排序元素），继续外层循环
	ret                     # 排序完成，返回调用者

main:
	irmovq array,%rdi
	irmovq $6,%rsi
	call bubble_a
	ret

	.pos 0x200
stack:
```
# Part B
本部分相对旧版来说，改动较大，也是本篇博客聚焦的主要部分，在Part B中你需要在./archlab-project/sim/src/architectures/extra内修改.rs文件。
在修改完后请使用
```bash
cargo build
```
来重新构建项目
同样的，你可以通过
```bash
grader part-b
```
获得你的评分

在做本节内容前，推荐安装 VS Code rust analyzer以获得高亮编码体验：
```md
https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer
```
需要注意的是，rust-analyzer必须要求工作区内有Cargo.toml文件，否则无法使用。
## IOPQ
本部分你将在seq_full.rs文件中添加IOPQ运算符，这部分的主要工作在Fetch，Decode与Execute部分，剩下部分则不太需要更改
### Fetch阶段
在这个阶段我们需要确保在取指时能正确读取IOPQ，包括认定IOPQ合法，需要读取寄存器，需要读取立即数,需要修改部分如下：
```rust
bool instr_valid = icode in // CMOVX is the same as RRMOVQ
    { NOP, HALT, CMOVX, IRMOVQ, RMMOVQ, MRMOVQ,
    OPQ, JX, CALL, RET, PUSHQ, POPQ, IOPQ };

// Does fetched instruction require a regid byte?
bool need_regids =
    icode in { CMOVX, OPQ, PUSHQ, POPQ, IRMOVQ, RMMOVQ, MRMOVQ, IOPQ };

// Does fetched instruction require a constant word?
bool need_valC = icode in { IRMOVQ, RMMOVQ, MRMOVQ, JX, CALL, IOPQ };
```
### Decode阶段
在decode阶段，由于IOPQ的srcA为F，即空寄存器，srcB为读取的寄存器rB，需要写入的寄存器（即dstE）为rB，dstM（需要写入的内存位置）为空，则我们需要修改以下部分：
```rust
u8 srcB = [
    icode in { OPQ, RMMOVQ, MRMOVQ, IOPQ } : ialign.rB;
    icode in { PUSHQ, POPQ, CALL, RET } : RSP;
    true : RNONE; // Don't need register
];
u8 dstE = [
    icode in { CMOVX } && cnd : ialign.rB;
    icode in { IRMOVQ, OPQ, IOPQ} : ialign.rB;
    icode in { PUSHQ, POPQ, CALL, RET } : RSP;
    true : RNONE; // Don't write any register
];
```
### Execute阶段
在execute阶段，我们需要读取两个运算的数以及运算符，并且不要忘记了IOPQ同样需要设置条件码
```rust
// Select input A to ALU
u64 aluA = [
    icode in { CMOVX, OPQ} : reg_read.valA;
    icode in { IRMOVQ, RMMOVQ, MRMOVQ, IOPQ } : ialign.valC;
    icode in { CALL, PUSHQ } : NEG_8;
    icode in { RET, POPQ } : 8;
    // Other instructions don't need ALU
];

// Select input B to ALU
u64 aluB = [
    icode in { RMMOVQ, MRMOVQ, OPQ, CALL,
              PUSHQ, RET, POPQ , IOPQ } : reg_read.valB;
    icode in { CMOVX, IRMOVQ } : 0;
    // Other instructions don't need ALU
];

// Set the ALU function
u8 alufun = [
    icode in { OPQ, IOPQ } : ifun;
    true : ADD;
];

bool set_cc = icode in { OPQ, IOPQ };
```
## Pipeline
本部分你将参考pipe_s2.rs文件填写一系列的pipeline文件
推荐在填写时使用vscode的文件比对功能。
### pipe_s3a
在 pipe_s3a中，我们将把流水线分为三阶段，分别是Fetch阶段，Decode阶段以及Execute阶段（包含Execute之后的所有阶段）
在这个阶段，我们主要处理的是取指和data hazard两个问题。当然还包含其他的填空，但是在这里就不再赘述

在取指阶段，因为不同的阶段我们才能确定具体的取指数据,因此，我们需要读取D与E的icode以获得地址
```rust
u64 f_pc = [
    // Call.  Use instruction constant
    // If the previous instruction is CALL, the constant value should be the next PC
    // valC is from Fetch Stage, thus the last cycle
    D.icode == CALL : D.valC;
    // Taken branch.  Use instruction constant
    E.icode == JX && e_cnd : E.valC;
    // Completion of RET instruction.  Use value from stack
    // valM is from DEMW stage, thus the current cycle
    E.icode == RET : e_valM;//在E阶段e_valM得到的是栈中弹出的值
    // Default: Use incremented PC
    1 : F.valP;
];
```
值得注意的是，icode对应的阶段和读取的值对应的阶段应该是相同的。

关于data hazard，判定data hazard的方法其实就在于看D阶段读取的寄存器是否是E阶段所要改动的寄存器，即可写出
```rust
bool data_harzard = (d_srcA != RNONE && d_srcA in { e_dstE, e_dstM })
    || (d_srcB != RNONE && d_srcB in { e_dstE, e_dstM });
```
在遇到data hazard时，我们需要停滞一个阶段，即E阶段bubble，F,D阶段stall，可写出：
```rust
bool f_stall = D.icode in { JX, RET } || data_harzard;

@set_stage(f, {
    stall: f_stall,
});


bool d_stall = data_harzard;

bool d_bubble = D.icode in { JX,RET } && !d_stall;

@set_stage(d, {
    stall: d_stall,
    bubble: d_bubble,
});

// A data hazard has occurred, and the preceding stage is waiting. 
// This stage has nothing to do, so we insert a bubble.
bool e_bubble = data_harzard;
```
### pipe_s3b
在这个阶段，我们主要处理的是使用forward来解决data hazard
```rust
u64 d_valA = [
    d_srcA == e_dstE : e_valE;
    d_srcA == e_dstM : e_valM;
    1: reg_read.valA;
];
u64 d_valB = [
    d_srcB == e_dstE : e_valE;
    d_srcB == e_dstM : e_valM;
    1: reg_read.valB;
];
```
通过在Decode阶段更改读取的值，我们可以避免在data hazard出现的停顿
同样的，我们也不再需要d_stall了
### pipe_s3c
在这个阶段，我们要使用branch prediction来解决icode为JX时的停顿问题
为了做branch prediction，我们先预测出一个pc
```rust
u64 f_pred_pc = [
    // Always take the jump
    f_icode == JX : f_valC;
    // Default: Use incremented PC
    1: f_valP;
];
```
在取指令的时候我们就可以进行判断，当JX && !e_cnd时，我们就回去取valP
```rust
u64 f_pc = [
    // Call.  Use instruction constant
    // If the previous instruction is CALL, the constant value should be the next PC
    // valC is from Fetch Stage, thus the last cycle
    D.icode == CALL : D.valC;
    // Branch misprediction.  Use incremental PC
    E.icode == JX && !e_cnd : E.valP;
    // Completion of RET instruction.  Use value from stack
    // valM is from DEMW stage, thus the current cycle
    E.icode == RET : e_valM;
    // Default: Use predicted PC
    1 : F.pred_pc;
];
```
同时，branch prediction也会给我们带来副作用，当预测错误的时候，我们需要E阶段bubble，把错误的在D阶段的指令给排除。
当D阶段的icode是RET,E阶段是JX时，我们已经将D阶段指令排除了，所以不需要对RET进行额外的处理。
```rust
// If a branch misprediction is detected during the Execute stage, it means that
// the instruction currently in the Decode stage is invalid. Therefore, the next
// cycle’s Execute stage needs to insert a bubble.
bool branch_mispred = E.icode == JX && !e_cnd;

// If the current instruction in the Decode stage is a RET, then the instruction
// in the current Fetch stage is invalid. Therefore, the next cycle’s Fetch stage 
// needs to insert a bubble.
bool ret_harzard = D.icode == RET;

// If both a branch misprediction and a RET hazard occur at the same time, since 
// the jump instruction is executed before the RET, the RET should not have been 
// executed, so a stall is not needed.
bool f_stall = ret_harzard && !branch_mispred;

@set_stage(f, {
    stall: f_stall,
});


bool d_stall = false;

// If both a branch misprediction and a ret hazard occur at the same time,
// since the jump instruction is executed before the RET, the RET should not
// have been executed. Therefore, a bubble is not needed.
bool d_bubble = ret_harzard && !branch_mispred;

@set_stage(d, {
    stall: d_stall,
    bubble: d_bubble,
});

bool e_bubble = branch_mispred;
```
### pipe_s3d
本阶段只是将寄存器读写在硬件层面上写在了一起，流水线逻辑没有太大改变，所以不再赘述
